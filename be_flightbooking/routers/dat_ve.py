from fastapi import APIRouter, HTTPException
from fastapi.responses import JSONResponse
from fastapi import Query
from models.dat_ve import DatVe
from utils.spark import load_df, invalidate_cache
from utils.spark_views import cached_views
from utils.env_loader import MONGO_DB, MONGO_URI
from pymongo import MongoClient
from datetime import datetime, date
import pandas as pd
import uuid

router = APIRouter()
client = MongoClient(MONGO_URI)
db = client[MONGO_DB]
dat_ve_collection = db["dat_ve"]


@router.post("", tags=["dat_ve"])
def add_dat_ve(dat_ve: DatVe):
    try:
        print("üöÄ D·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c t·ª´ client:", dat_ve.dict())

        df_dat_ve = cached_views["dat_ve"]
        df_khach_hang = cached_views["khach_hang"]
        df_hang_ve = cached_views["hang_ve"]
        df_tuyen_bay = cached_views["tuyen_bay"]

        # ‚úÖ Ki·ªÉm tra m√£ kh√°ch h√†ng
        if df_khach_hang.filter(df_khach_hang.ma_khach_hang == dat_ve.ma_khach_hang).count() == 0:
            raise HTTPException(status_code=400, detail="M√£ kh√°ch h√†ng kh√¥ng t·ªìn t·∫°i")

        # ‚úÖ Validation chi·ªÅu ƒëi (b·∫Øt bu·ªôc) - S·ª¨A L·∫†I
        if dat_ve.ma_hang_ve_di:
            if df_hang_ve.filter(df_hang_ve.ma_hang_ve == dat_ve.ma_hang_ve_di).count() == 0:
                raise HTTPException(status_code=400, detail="M√£ h·∫°ng v√© chi·ªÅu ƒëi kh√¥ng t·ªìn t·∫°i")
        
        if dat_ve.ma_tuyen_bay_di:
            if df_tuyen_bay.filter(df_tuyen_bay.ma_tuyen_bay == dat_ve.ma_tuyen_bay_di).count() == 0:
                raise HTTPException(status_code=400, detail="M√£ tuy·∫øn bay chi·ªÅu ƒëi kh√¥ng t·ªìn t·∫°i")

        # ‚úÖ Validation chi·ªÅu v·ªÅ (n·∫øu kh·ª© h·ªìi)
        if dat_ve.loai_chuyen_di == "Kh·ª© h·ªìi":
            if not dat_ve.ma_hang_ve_ve:
                raise HTTPException(status_code=400, detail="V√© kh·ª© h·ªìi c·∫ßn m√£ h·∫°ng v√© chi·ªÅu v·ªÅ")
            if not dat_ve.ma_tuyen_bay_ve:
                raise HTTPException(status_code=400, detail="V√© kh·ª© h·ªìi c·∫ßn m√£ tuy·∫øn bay chi·ªÅu v·ªÅ")
                
            if df_hang_ve.filter(df_hang_ve.ma_hang_ve == dat_ve.ma_hang_ve_ve).count() == 0:
                raise HTTPException(status_code=400, detail="M√£ h·∫°ng v√© chi·ªÅu v·ªÅ kh√¥ng t·ªìn t·∫°i")
            
            if df_tuyen_bay.filter(df_tuyen_bay.ma_tuyen_bay == dat_ve.ma_tuyen_bay_ve).count() == 0:
                raise HTTPException(status_code=400, detail="M√£ tuy·∫øn bay chi·ªÅu v·ªÅ kh√¥ng t·ªìn t·∫°i")

        # üÜï Sinh m√£ ƒë·∫∑t v√© n·∫øu ch∆∞a c√≥
        ma_dat_ve = dat_ve.ma_dat_ve or f"DV{uuid.uuid4().hex[:8].upper()}"

        # üí° Ki·ªÉm tra tr√πng m√£
        if "ma_dat_ve" in df_dat_ve.columns:
            if df_dat_ve.filter(df_dat_ve["ma_dat_ve"] == ma_dat_ve).count() > 0:
                raise HTTPException(status_code=400, detail="M√£ ƒë·∫∑t v√© ƒë√£ t·ªìn t·∫°i")

        # üîÑ Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ insert
        data_to_insert = dat_ve.dict()
        data_to_insert["ma_dat_ve"] = ma_dat_ve

        if isinstance(data_to_insert["ngay_dat"], date):
            data_to_insert["ngay_dat"] = datetime.combine(
                data_to_insert["ngay_dat"], datetime.min.time()
            )

        # üì• Ghi v√†o MongoDB
        insert_result = dat_ve_collection.insert_one(data_to_insert)
        invalidate_cache("dat_ve")

        # ‚úÖ Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ tr·∫£ v·ªÅ (convert datetime -> string)
        data_to_insert["_id"] = str(insert_result.inserted_id)
        data_to_insert["ngay_dat"] = data_to_insert["ngay_dat"].isoformat()

        print("‚úÖ ƒê·∫∑t v√© th√†nh c√¥ng:", ma_dat_ve)
        return JSONResponse(
            content={"message": "Th√™m ƒë·∫∑t v√© th√†nh c√¥ng", "dat_ve": data_to_insert}
        )

    except HTTPException as he:
        raise he
    except Exception as e:
        print("‚ùå L·ªói:", e)
        raise HTTPException(status_code=500, detail="L·ªói server n·ªôi b·ªô")

@router.get("", tags=["dat_ve"])
def get_existing_dat_ve(
    ma_khach_hang: str = Query(...), 
    loai_chuyen_di: str = Query(None)  # Optional cho new format
):
    try:
        # ‚úÖ T√¨m ki·∫øm linh ho·∫°t - ∆∞u ti√™n fields m·ªõi
        search_criteria = {"ma_khach_hang": ma_khach_hang}
        
        if loai_chuyen_di:
            search_criteria["loai_chuyen_di"] = loai_chuyen_di

        result = dat_ve_collection.find_one(
            search_criteria,
            sort=[("ngay_dat", -1)],  # ∆Øu ti√™n b·∫£n ghi g·∫ßn nh·∫•t
        )

        if not result:
            raise HTTPException(status_code=404, detail="Kh√¥ng t√¨m th·∫•y b·∫£n ghi ƒë·∫∑t v√©")

        return {
            "ma_dat_ve": result["ma_dat_ve"],
            "dat_ve": {
                "ma_khach_hang": result["ma_khach_hang"],
                "loai_chuyen_di": result.get("loai_chuyen_di", "M·ªôt chi·ªÅu"),
                "ma_chuyen_di": result.get("ma_chuyen_di"),  # Backward compatibility
                "ngay_dat": (
                    result["ngay_dat"].isoformat()
                    if isinstance(result["ngay_dat"], datetime)
                    else result["ngay_dat"]
                ),
                "ma_dat_ve": result["ma_dat_ve"],
                "ma_hang_ve_di": result.get("ma_hang_ve_di"),
                "ma_tuyen_bay_di": result.get("ma_tuyen_bay_di"),
                "ma_hang_ve_ve": result.get("ma_hang_ve_ve"),
                "ma_tuyen_bay_ve": result.get("ma_tuyen_bay_ve"),
                "trang_thai": result.get("trang_thai", "ƒêang x·ª≠ l√Ω"),
            },
        }

    except HTTPException as he:
        raise he
    except Exception as e:
        print("‚ùå L·ªói get_existing_dat_ve:", e)
        raise HTTPException(status_code=500, detail="L·ªói server n·ªôi b·ªô")


@router.delete("/{ma_dat_ve}", tags=["dat_ve"])
def cancel_dat_ve(ma_dat_ve: str):
    try:
        # T√¨m b·∫£n ghi ƒë·∫∑t v√©
        result = dat_ve_collection.find_one({"ma_dat_ve": ma_dat_ve})
        if not result:
            raise HTTPException(status_code=404, detail="Kh√¥ng t√¨m th·∫•y m√£ ƒë·∫∑t v√©")

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i sang "ƒê√£ h·ªßy"
        update_result = dat_ve_collection.update_one(
            {"ma_dat_ve": ma_dat_ve}, {"$set": {"trang_thai": "ƒê√£ h·ªßy"}}
        )

        if update_result.modified_count == 0:
            raise HTTPException(status_code=400, detail="Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i")

        # Invalidate cache Spark
        invalidate_cache("dat_ve")

        print(f"üö´ ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i h·ªßy v√© cho m√£ {ma_dat_ve}")
        return JSONResponse(content={"message": f"ƒê√£ h·ªßy v√© {ma_dat_ve} th√†nh c√¥ng"})

    except HTTPException as he:
        raise he
    except Exception as e:
        print("‚ùå L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i h·ªßy v√©:", e)
        raise HTTPException(status_code=500, detail="L·ªói server n·ªôi b·ªô")


@router.get("/all", tags=["dat_ve"])
def get_all_dat_ve_by_user(ma_khach_hang: str = Query(...)):
    try:
        # ‚úÖ Th·ª≠ truy v·∫•n tr·ª±c ti·∫øp t·ª´ MongoDB tr∆∞·ªõc
        mongo_results = list(dat_ve_collection.find({"ma_khach_hang": ma_khach_hang}).sort("ngay_dat", -1))
        
        if not mongo_results:
            print(f"‚ùå Kh√¥ng c√≥ data trong MongoDB cho kh√°ch h√†ng: {ma_khach_hang}")
            return JSONResponse(content=[])
        
        print(f"‚úÖ T√¨m th·∫•y {len(mongo_results)} records trong MongoDB")
        print("üîç Sample record:", mongo_results[0])
        
        # ‚úÖ Force reload Spark cache
        invalidate_cache("dat_ve")
        df_dat_ve = load_df("dat_ve")
        
        print(f"üîç Spark DataFrame count: {df_dat_ve.count()}")
        if df_dat_ve.count() == 0:
            print("‚ùå Spark DataFrame empty, return MongoDB data directly")
            # Convert MongoDB data v√† return tr·ª±c ti·∫øp
            for record in mongo_results:
                record["_id"] = str(record["_id"])
                if isinstance(record.get("ngay_dat"), datetime):
                    record["ngay_dat"] = record["ngay_dat"].strftime('%Y-%m-%d %H:%M:%S')
            return JSONResponse(content=mongo_results)
        
        print("üîç Spark columns:", df_dat_ve.columns)
        
        # ‚úÖ Ki·ªÉm tra columns m·ªõi c√≥ t·ªìn t·∫°i kh√¥ng
        required_new_cols = ["ma_hang_ve_di", "ma_tuyen_bay_di", "loai_chuyen_di"]
        missing_cols = [col for col in required_new_cols if col not in df_dat_ve.columns]
        
        if missing_cols:
            print(f"‚ùå Missing columns: {missing_cols}, fallback to MongoDB")
            # Fallback to MongoDB data
            for record in mongo_results:
                record["_id"] = str(record["_id"])
                if isinstance(record.get("ngay_dat"), datetime):
                    record["ngay_dat"] = record["ngay_dat"].strftime('%Y-%m-%d %H:%M:%S')
            return JSONResponse(content=mongo_results)

        # ‚úÖ N·∫øu c√≥ ƒë·ªß columns, ch·∫°y Spark query
        spark = df_dat_ve.sparkSession

        # Register views
        for name in ["dat_ve", "hang_ve", "tuyen_bay", "khach_hang", "san_bay"]:
            cached_views[name].unpersist()
            cached_views[name].createOrReplaceTempView(name)

        query = f"""
        SELECT
            dv.ma_dat_ve,
            date_format(dv.ngay_dat, 'yyyy-MM-dd HH:mm:ss') as ngay_dat,
            dv.trang_thai,
            dv.ma_khach_hang,
            dv.loai_chuyen_di,
            
            -- Fields m·ªõi
            dv.ma_hang_ve_di,
            dv.ma_tuyen_bay_di,
            COALESCE(hv_di.vi_tri_ngoi, 'N/A') AS vi_tri_ngoi_di,
            COALESCE(tb_di.ma_san_bay_di, 'N/A') AS ma_san_bay_di,
            COALESCE(tb_di.ma_san_bay_den, 'N/A') AS ma_san_bay_den_di,
            COALESCE(sb_di_start.ten_san_bay, 'N/A') AS ten_san_bay_di,
            COALESCE(sb_di_end.ten_san_bay, 'N/A') AS ten_san_bay_den_di,
            
            -- Fields chi·ªÅu v·ªÅ
            dv.ma_hang_ve_ve,
            dv.ma_tuyen_bay_ve,
            COALESCE(hv_ve.vi_tri_ngoi, NULL) AS vi_tri_ngoi_ve,
            COALESCE(tb_ve.ma_san_bay_di, NULL) AS ma_san_bay_di_ve,
            COALESCE(tb_ve.ma_san_bay_den, NULL) AS ma_san_bay_den_ve,
            COALESCE(sb_ve_start.ten_san_bay, NULL) AS ten_san_bay_di_ve,
            COALESCE(sb_ve_end.ten_san_bay, NULL) AS ten_san_bay_den_ve
            
        FROM dat_ve dv
        LEFT JOIN hang_ve hv_di ON dv.ma_hang_ve_di = hv_di.ma_hang_ve
        LEFT JOIN tuyen_bay tb_di ON dv.ma_tuyen_bay_di = tb_di.ma_tuyen_bay
        LEFT JOIN san_bay sb_di_start ON tb_di.ma_san_bay_di = sb_di_start.ma_san_bay
        LEFT JOIN san_bay sb_di_end ON tb_di.ma_san_bay_den = sb_di_end.ma_san_bay
        
        LEFT JOIN hang_ve hv_ve ON dv.ma_hang_ve_ve = hv_ve.ma_hang_ve
        LEFT JOIN tuyen_bay tb_ve ON dv.ma_tuyen_bay_ve = tb_ve.ma_tuyen_bay
        LEFT JOIN san_bay sb_ve_start ON tb_ve.ma_san_bay_di = sb_ve_start.ma_san_bay
        LEFT JOIN san_bay sb_ve_end ON tb_ve.ma_san_bay_den = sb_ve_end.ma_san_bay
        
        WHERE dv.ma_khach_hang = '{ma_khach_hang}'
        ORDER BY dv.ngay_dat DESC
        """
        
        df = spark.sql(query)
        pdf = df.toPandas()
        
        print("‚úÖ Spark query th√†nh c√¥ng, s·ªë records:", len(pdf))
        return JSONResponse(content=pdf.to_dict(orient="records"))

    except Exception as e:
        print("‚ùå L·ªói get_all_dat_ve_by_user:", e)
        # ‚úÖ Fallback cu·ªëi c√πng - return MongoDB data
        try:
            mongo_results = list(dat_ve_collection.find({"ma_khach_hang": ma_khach_hang}).sort("ngay_dat", -1))
            for record in mongo_results:
                record["_id"] = str(record["_id"])
                if isinstance(record.get("ngay_dat"), datetime):
                    record["ngay_dat"] = record["ngay_dat"].strftime('%Y-%m-%d %H:%M:%S')
            print(f"‚úÖ Fallback success: {len(mongo_results)} records")
            return JSONResponse(content=mongo_results)
        except Exception as fallback_error:
            print("‚ùå Fallback failed:", fallback_error)
            raise HTTPException(status_code=500, detail="L·ªói server n·ªôi b·ªô")
    

@router.delete("/delete-all", tags=["dat_ve"])
def delete_all_dat_ve():
    """X√≥a t·∫•t c·∫£ d·ªØ li·ªáu ƒë·∫∑t v√© - CH·ªà D√ôNG ƒê·ªÇ TEST"""
    try:
        # X√≥a t·∫•t c·∫£ records trong collection dat_ve
        result = dat_ve_collection.delete_many({})
        
        # Invalidate cache
        invalidate_cache("dat_ve")
        
        print(f"üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ {result.deleted_count} records ƒë·∫∑t v√©")
        return JSONResponse(content={
            "message": f"ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu ƒë·∫∑t v√© th√†nh c√¥ng",
            "deleted_count": result.deleted_count
        })
        
    except Exception as e:
        print("‚ùå L·ªói khi x√≥a t·∫•t c·∫£ ƒë·∫∑t v√©:", e)
        raise HTTPException(status_code=500, detail="L·ªói server n·ªôi b·ªô")
    
# ‚úÖ Hybrid approach: D√πng Spark ƒë·ªÉ validate + MongoDB ƒë·ªÉ update
@router.patch("/{ma_dat_ve}/refund", tags=["dat_ve"])
def request_refund_ticket_hybrid(ma_dat_ve: str):
    try:
        # üîç B∆Ø·ªöC 1: D√πng SPARK ƒë·ªÉ VALIDATE (READ operations)
        spark = cached_views["dat_ve"].sparkSession
        
        # Register views c·∫ßn thi·∫øt
        for view_name in ["dat_ve", "hang_ve"]:
            cached_views[view_name].createOrReplaceTempView(view_name)

        # Spark query ƒë·ªÉ validation
        validation_query = f"""
        SELECT 
            dv.ma_dat_ve,
            dv.trang_thai,
            dv.ma_khach_hang,
            dv.ma_hang_ve_di,
            hv.refundable,
            hv.vi_tri_ngoi
        FROM dat_ve dv
        LEFT JOIN hang_ve hv ON dv.ma_hang_ve_di = hv.ma_hang_ve
        WHERE dv.ma_dat_ve = '{ma_dat_ve}'
        """
        
        df_result = spark.sql(validation_query)
        results = df_result.collect()
        
        if len(results) == 0:
            raise HTTPException(status_code=404, detail="Kh√¥ng t√¨m th·∫•y m√£ ƒë·∫∑t v√©")
        
        ticket_info = results[0]
        
        # ‚úÖ Ki·ªÉm tra tr·∫°ng th√°i
        if ticket_info["trang_thai"] != "ƒê√£ thanh to√°n":
            raise HTTPException(
                status_code=400, 
                detail=f"Ch·ªâ c√≥ th·ªÉ ho√†n v√© ƒë√£ thanh to√°n. Tr·∫°ng th√°i hi·ªán t·∫°i: {ticket_info['trang_thai']}"
            )

        # ‚úÖ Ki·ªÉm tra ƒëi·ªÅu ki·ªán refundable t·ª´ Spark
        is_refundable = ticket_info["refundable"] if ticket_info["refundable"] is not None else True
        
        if not is_refundable:
            raise HTTPException(
                status_code=400, 
                detail=f"Lo·∫°i v√© {ticket_info['vi_tri_ngoi']} kh√¥ng th·ªÉ ho√†n. Vui l√≤ng li√™n h·ªá hotline ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£."
            )

        print(f"‚úÖ Spark validation passed - Kh√°ch h√†ng: {ticket_info['ma_khach_hang']}, H·∫°ng v√©: {ticket_info['vi_tri_ngoi']}")

        # üíæ B∆Ø·ªöC 2: Ch·ªâ c·∫≠p nh·∫≠t dat_ve collection
        update_result = dat_ve_collection.update_one(
            {"ma_dat_ve": ma_dat_ve}, 
            {
                "$set": {
                    "trang_thai": "Ch·ªù duy·ªát ho√†n v√©",
                    "ngay_yeu_cau_hoan": datetime.now(),
                    "ly_do_hoan": "Kh√°ch h√†ng y√™u c·∫ßu ho√†n v√©",
                    "nguoi_yeu_cau": ticket_info["ma_khach_hang"],
                    "trang_thai_duyet": "Ch·ªù x·ª≠ l√Ω",
                    "gia_ve_hoan": 1500000,
                    "admin_xem": False  # üÜï ƒê√°nh d·∫•u admin ch∆∞a xem
                }
            }
        )

        if update_result.modified_count == 0:
            raise HTTPException(status_code=400, detail="Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i")

        # üóëÔ∏è B·ªé PH·∫¶N T·∫†O NOTIFICATION

        # üîÑ SYNC d·ªØ li·ªáu
        invalidate_cache("dat_ve")

        return JSONResponse(content={
            "message": f"Y√™u c·∫ßu ho√†n v√© {ma_dat_ve} ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng. Ch√∫ng t√¥i s·∫Ω x·ª≠ l√Ω trong v√≤ng 24-48h.",
            "ma_dat_ve": ma_dat_ve,
            "trang_thai_moi": "Ch·ªù duy·ªát ho√†n v√©",
            "thoi_gian_xu_ly": "24-48 gi·ªù",
            "hang_ve": ticket_info["vi_tri_ngoi"],
            "khach_hang": ticket_info["ma_khach_hang"]
        })

    except HTTPException as he:
        raise he
    except Exception as e:
        print("‚ùå L·ªói hybrid refund request:", e)
        raise HTTPException(status_code=500, detail="L·ªói server n·ªôi b·ªô")


@router.patch("/{ma_dat_ve}/approve-refund", tags=["admin"])
def approve_refund_hybrid(ma_dat_ve: str, approved: bool):
    try:
        # üîç T√¨m th√¥ng tin v√© t·ª´ MongoDB
        ticket_doc = dat_ve_collection.find_one({"ma_dat_ve": ma_dat_ve})
        
        if not ticket_doc:
            raise HTTPException(status_code=404, detail="Kh√¥ng t√¨m th·∫•y m√£ ƒë·∫∑t v√©")
        
        if ticket_doc["trang_thai"] != "Ch·ªù duy·ªát ho√†n v√©":
            raise HTTPException(
                status_code=400, 
                detail=f"V√© kh√¥ng ·ªü tr·∫°ng th√°i ch·ªù duy·ªát. Tr·∫°ng th√°i hi·ªán t·∫°i: {ticket_doc['trang_thai']}"
            )

        # üíæ Update v√© trong MongoDB
        if approved:
            # ‚úÖ DUY·ªÜT: Chuy·ªÉn th√†nh "ƒê√£ ho√†n v√©"
            new_status = "ƒê√£ ho√†n v√©"
            update_data = {
                "trang_thai": new_status,
                "ngay_duyet_hoan": datetime.now(),
                "trang_thai_duyet": "ƒê√£ duy·ªát",
                "admin_duyet": "SYSTEM",
                "ngay_hoan_ve": datetime.now(),
                "so_tien_hoan": ticket_doc.get("gia_ve_hoan", 1500000)
            }
        else:
            # ‚ùå T·ª™ CH·ªêI: Chuy·ªÉn v·ªÅ l·∫°i "ƒê√£ thanh to√°n"
            new_status = "ƒê√£ thanh to√°n"
            update_data = {
                "trang_thai": new_status,
                "ngay_duyet_hoan": datetime.now(),
                "trang_thai_duyet": "T·ª´ ch·ªëi",
                "admin_duyet": "SYSTEM",
                "ly_do_tu_choi": "Admin t·ª´ ch·ªëi y√™u c·∫ßu ho√†n v√©"
            }

        # Update v√©
        dat_ve_collection.update_one(
            {"ma_dat_ve": ma_dat_ve}, 
            {"$set": update_data}
        )

        # N·∫øu t·ª´ ch·ªëi, x√≥a c√°c field li√™n quan ƒë·∫øn ho√†n v√©
        if not approved:
            dat_ve_collection.update_one(
                {"ma_dat_ve": ma_dat_ve}, 
                {"$unset": {
                    "ngay_yeu_cau_hoan": "",
                    "gia_ve_hoan": "",
                    "nguoi_yeu_cau": "",
                    "admin_xem": ""
                }}
            )

        # üóëÔ∏è B·ªé PH·∫¶N T·∫†O NOTIFICATION

        # üîÑ SYNC d·ªØ li·ªáu
        invalidate_cache("dat_ve")

        action_text = "ƒê√£ duy·ªát" if approved else "ƒê√£ t·ª´ ch·ªëi"
        print(f"‚úÖ {action_text} ho√†n v√© {ma_dat_ve}")
        print(f"üìù Tr·∫°ng th√°i m·ªõi: {new_status}")

        return JSONResponse(content={
            "message": f"{action_text} ho√†n v√© {ma_dat_ve}",
            "approved": approved,
            "new_status": new_status,
            "so_tien_hoan": ticket_doc.get("gia_ve_hoan", 1500000) if approved else 0,
            "note": "V√© ƒë∆∞·ª£c tr·∫£ v·ªÅ tr·∫°ng th√°i ƒë√£ thanh to√°n" if not approved else "V√© ƒë√£ ƒë∆∞·ª£c ho√†n th√†nh c√¥ng"
        })

    except HTTPException as he:
        raise he
    except Exception as e:
        print(f"‚ùå L·ªói hybrid approve refund: {e}")
        raise HTTPException(status_code=500, detail="L·ªói server n·ªôi b·ªô")
    
